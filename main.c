#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  isRed,          sensorDigitalIn)
#pragma config(Sensor, dgtl6,  wallAuton,      sensorDigitalIn)
#pragma config(Motor,  port2,           rightBackMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightFrontMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           scorer,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftFrontMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftBackMotor, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

const float TRACK_WIDTH_FEET = 	13.25 / 12.0
const float WHEEL_DIAMETER_FEET = 4.0 / 12.0;
const float WHEEL_CIRCUM_FEET = PI * WHEEL_DIAMETER_FEET;
const float ENCODER_CONVERSION = (1.0 / 360.0) * (36.0 / 60.0) * WHEEL_CIRCUM_FEET;

const float AUTON_MAX_VEL = 1.5;
const float AUTON_MAX_ACCEL = 1.0;
const float AUTON_SPEED = 127 * 0.5;
const float EMPERICAL_VELOCITY_127 = (52.0 / 12.0) / 1.5;

const float NINETY = 69;

/*** UTIL ***/

float deadband(float value, float deadband) {
	if (abs(value) < deadband) return 0;

	return value;
}

float min(float a, float b) {
	if (a < b) return a;
	return b;
}

float max(float a, float b) {
	if (a > b) return a;
	return b;
}

float clamp(float a, float lower, float upper) {
	return max(min(a, upper), lower);
}


float toDegrees(float rad) {
	return rad / PI * 180.0;
}

float toRad(float deg) {
	return deg / 180.0 * PI;
}

/*** ENCODER ***/

float getLeftDistance() {
	return SensorValue[leftEncoder] * ENCODER_CONVERSION;
}

float getRightDistance() {
	return SensorValue[rightEncoder] * ENCODER_CONVERSION;
}

float getDistance() {
	return (getLeftDistance() + getRightDistance()) / 2.0;
}

float getAngleRad() {
	return (getLeftDistance() - getRightDistance()) / TRACK_WIDTH_FEET;
}

/*** DRIVE ***/

void arcadeDrive(float drive, float turn) {
	motor[leftFrontMotor]  = (drive + turn) * 0.85;
	motor[leftBackMotor]  = (drive + turn) * 0.85;

	motor[rightFrontMotor] = drive - turn;
	motor[rightBackMotor] = drive - turn;
}

void stopDrivetrain() {
	motor[leftFrontMotor] = 0;
	motor[rightFrontMotor] = 0;
	motor[leftBackMotor] = 0;
	motor[rightBackMotor] = 0;
}

void forceStopDrivetrain() {
	arcadeDrive(-AUTON_SPEED, 0);
	wait(0.1);
	stopDrivetrain();
}

/*** SENSORS ***/

bool isRedAlliance() {
	return !SensorValue[isRed];
}

/*** AUTON DRIVE ***/

float A;
void driveDist(float feet) {
	float direction = sgn(feet);

	feet = abs(feet);

	float leftStart = getLeftDistance();
	float rightStart = getRightDistance();

	while (abs(getLeftDistance() - leftStart) < feet || abs(getRightDistance() - rightStart) < feet) {
		float distGone = getDistance() - (leftStart + rightStart) / 2.0;
		float distLeft = feet - distGone;

		// ramps from 0 -> AUTON_SPEED in first 1/4 of path
		// and AUTON_SPEED -> 0 in last 1/4 of path
		// clamped from 60% to 100%
		float speedPct = clamp(min(distGone, distLeft) / (feet / 4.0), 0.6, 1.0);

		A = 127.0 * speedPct;

		arcadeDrive(direction * 127.0 * speedPct, 0);
	}

	stopDrivetrain();
}

void turnAngle(float deg) {
	float direction = sgn(deg);
	float rad = abs(toRad(deg));

	float radStart = getAngleRad();

	while (abs(getAngleRad() - radStart) < rad - toRad(5)) {
		arcadeDrive(0, direction * 60.0);
	}

	//arcadeDrive(0, -direction * 60.0);
	//wait(0.2);
	arcadeDrive(0, 0);
}

void runScorerSeconds(float sec) {
	time1[T1] = 0;

	while (time1[T1] / 1000.0 < sec) motor[scorer] = 127.0;

	motor[scorer] = 0;
}

void pre_auton() {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
}


float angle;

task autonomous() {
	// run by wall
	if (!SensorValue[wallAuton]) {
		driveDist(3.5);

		if (isRedAlliance()) {
			turnAngle(-NINETY);
		} else {
			turnAngle(+NINETY);
		}

		driveDist(2.0);
	}
	else {
		driveDist(2.75);
	}

	motor[intake] = 127;
	motor[scorer] = 127;
	wait(2);
	motor[scorer] = 0;
	motor[intake] = 0;
}

task usercontrol() {
	bool runIntake = false;

	bool lastIntakeToggleButton = false;
	bool lastScorePrepButton = false;
	int lastScoreSpeed = 0;

	while (true) {
		angle = toDegrees(getAngleRad());
		arcadeDrive(deadband(vexRT[Ch3], 10), deadband(vexRT[Ch1], 10));

		// when button goes from false to true, toggle intake
		if (!lastIntakeToggleButton && vexRT[Btn6U]) {
			runIntake = !runIntake;
		}

		lastIntakeToggleButton = vexRT[Btn6U];


		if (vexRT[Btn6D]) {
			motor[scorer] = 127;
			lastScoreSpeed = 127;
		} else if (vexRT[Btn5D]) {
			motor[scorer] = -127;
			lastScoreSpeed = -127;
	  } else {
	  	if (lastScoreSpeed != 0) {
	  		motor[intake] = 0;
	  	}

			motor[scorer] = 0;
			lastScoreSpeed = 0;
		}

		if (lastScoreSpeed < 0) {
			motor[intake] = -127;
		} else {
			motor[intake] = runIntake ? 127 : 0;
		}

		if (!lastScorePrepButton && vexRT[Btn5U]) {
			runScorerSeconds(1.5);
		}

		lastScorePrepButton = vexRT[Btn5U];
	}
}
